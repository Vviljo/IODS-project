# Econometrics 2, Autumn 2018
# Solutions 3
###################################################
rm(list = ls()) # empty the work space
###############################################################################
## Exercise 5 ################################################################
library(urca)
library(tseries)
library(forecast)
REER = read.csv("REER_2016.csv", header=TRUE, sep=";", dec=",")
CUR  = colnames(REER[,-1])
#Decide based on the plot of the logarithimzed series and the corresponding
#ACF on stationarity of REER for Australia and Mexico
plot(log(REER[-(1:111),"Australia"]), type="l")
plot(log(REER[-(1:111),"Mexico"]), type="l")
acf(log(REER[-(1:111),"Australia"]))
acf(log(REER[-(1:111),"Mexico"]))
acf(log(REER[-(1:111),"Australia"]))
R.indv = NULL
for ( i in CUR){
x = log(REER[-(1:111),i])  # remove Bretton Woods periods and logarithmize
# ADF-test with drift
pmax = round(12*(length(x)/100)^0.25, 0)  # truncation lag according to Schwert (1989)
R.adf = ur.df(x, type="drift", selectlags="AIC", lags=pmax)
R.adf_tp = punitroot(q=R.adf@teststat[1], N=length(x), trend="c", statistic="t") # approximate p-values by MacKinnon (1996)
# KPSS-test with drift
R.kpss = kpss.test(x, null="Level", lshort=FALSE)
# store results
R.indv = rbind(R.indv, data.frame(Country=i,
ADF_lag=length(R.adf@testreg$coefficients[,1])-2,
ADF_phi=R.adf@testreg$coefficients[2,1],
ADF_t  =R.adf@teststat[1],
ADF_tp =R.adf_tp,
ADF_int=R.adf@testreg$coefficients[1,1],
ADF_inp=R.adf@testreg$coefficients[1,4],
KPSS_s =unname(R.kpss$statistic),
KPSS_p =R.kpss$p.value))
}
R.indv
R.indv
?ur.df()
?kpss.test()
dataset = read.table("TPdata.txt",header=TRUE)  # LOAD THE DATA
y<-log(dataset$YER)
c<-log(dataset$PCR)
plot(cbind(y,c), type="l")
plot(y,ylim=c(12.5,14.5), type="l")
lines(c,col="blue")
adf = ur.df(y, type="trend", selectlags="BIC")
summary(adf)
adf = ur.df(c, type="trend", selectlags="BIC")
summary(adf)
# We regress by standard OLS including constant term
ciregression = lm(c~y)
summary(ciregression)
# coefficients (parameters of the cointegrating vector) signicicant
# obtain the residual c-beta0-beta1*y
e = ciregression$residuals # z=c-beta*y
plot(e,type="l")
# As realistic alternative for unit root is that the series is stationary with constant mean,
# we add a drift term to the test regression. (Note that we do that even though the series has zero mean
# by construction. The inclusion only changes the used table for critical values)
adf = ur.df(e, type="drift", selectlags="BIC")  # ADF TEST OF THE RESIDUALS
summary(adf)
austr_arima<-auto.arima(log(REER[-(1:111),"Australia"]), ic="aic", seasonal=FALSE)
austr_arima
library(urca)
library(tseries)
library(forecast)
REER = read.csv("REER_2016.csv", header=TRUE, sep=";", dec=",")
CUR  = colnames(REER[,-1])
#Decide based on the plot of the logarithimzed series and the corresponding
#ACF on stationarity of REER for Australia and Mexico
plot(log(REER[-(1:111),"Australia"]), type="l")
plot(log(REER[-(1:111),"Mexico"]), type="l")
acf(log(REER[-(1:111),"Australia"]))
acf(log(REER[-(1:111),"Mexico"]))
R.indv = NULL
for ( i in CUR){
x = log(REER[-(1:111),i])  # remove Bretton Woods periods and logarithmize
# ADF-test with drift
pmax = round(12*(length(x)/100)^0.25, 0)  # truncation lag according to Schwert (1989)
R.adf = ur.df(x, type="drift", selectlags="AIC", lags=pmax)
R.adf_tp = punitroot(q=R.adf@teststat[1], N=length(x), trend="c", statistic="t") # approximate p-values by MacKinnon (1996)
# KPSS-test with drift
R.kpss = kpss.test(x, null="Level", lshort=FALSE)
# store results
R.indv = rbind(R.indv, data.frame(Country=i,
ADF_lag=length(R.adf@testreg$coefficients[,1])-2,
ADF_phi=R.adf@testreg$coefficients[2,1],
ADF_t  =R.adf@teststat[1],
ADF_tp =R.adf_tp,
ADF_int=R.adf@testreg$coefficients[1,1],
ADF_inp=R.adf@testreg$coefficients[1,4],
KPSS_s =unname(R.kpss$statistic),
KPSS_p =R.kpss$p.value))
}
R.indv
austr_arima<-auto.arima(log(REER[-(1:111),"Australia"]), ic="aic", seasonal=FALSE)
austr_arima
dataset = read.table("TPdata.txt",header=TRUE)  # LOAD THE DATA
y<-log(dataset$YER)
c<-log(dataset$PCR)
plot(cbind(y,c), type="l")
plot(y,ylim=c(12.5,14.5), type="l")
lines(c,col="blue")
# Both series have a trend
###############################################################################
## Exercise 5 ################################################################
library(urca)
library(tseries)
library(forecast)
R.indv
adf = ur.df(y, type="trend", selectlags="BIC")
summary(adf)
adf = ur.df(c, type="trend", selectlags="BIC")
summary(adf)
# We regress by standard OLS including constant term
ciregression = lm(c~y)
# coefficients (parameters of the cointegrating vector) signicicant
# obtain the residual c-beta0-beta1*y
e = ciregression$residuals # z=c-beta*y
plot(e,type="l")
# As realistic alternative for unit root is that the series is stationary with constant mean,
# we add a drift term to the test regression. (Note that we do that even though the series has zero mean
# by construction. The inclusion only changes the used table for critical values)
adf = ur.df(e, type="drift", selectlags="BIC")  # ADF TEST OF THE RESIDUALS
summary(adf)
# As realistic alternative for unit root is that the series is stationary with constant mean,
# we add a drift term to the test regression. (Note that we do that even though the series has zero mean
# by construction. The inclusion only changes the used table for critical values)
adf = ur.df(e, type="none", selectlags="BIC")  # ADF TEST OF THE RESIDUALS
summary(adf)
library(urca)
library(tseries)
library(forecast)
REER = read.csv("REER_2016.csv", header=TRUE, sep=";", dec=",")
CUR  = colnames(REER[,-1])
#Decide based on the plot of the logarithimzed series and the corresponding
#ACF on stationarity of REER for Australia and Mexico
plot(log(REER[-(1:111),"Australia"]), type="l")
plot(log(REER[-(1:111),"Mexico"]), type="l")
acf(log(REER[-(1:111),"Australia"]))
acf(log(REER[-(1:111),"Mexico"]))
R.indv
austr_arima
austr_arima<-auto.arima(log(REER[-(1:111),"Australia"]), ic="aic", seasonal=FALSE)
austr_arima
dataset = read.table("TPdata.txt",header=TRUE)  # LOAD THE DATA
y<-log(dataset$YER)
c<-log(dataset$PCR)
plot(cbind(y,c), type="l")
plot(y,ylim=c(12.5,14.5), type="l")
lines(c,col="blue")
adf = ur.df(y, type="trend", selectlags="BIC")
summary(adf)
adf = ur.df(c, type="trend", selectlags="BIC")
summary(adf)
# We regress by standard OLS including constant term
ciregression = lm(c~y)
# coefficients (parameters of the cointegrating vector) signicicant
# obtain the residual c-beta0-beta1*y
e = ciregression$residuals # z=c-beta*y
plot(e,type="l")
# As realistic alternative for unit root is that the series is stationary with constant mean,
# we add a drift term to the test regression. (Note that we do that even though the series has zero mean
# by construction. The inclusion only changes the used table for critical values)
adf = ur.df(e, type="drift", selectlags="BIC")  # ADF TEST OF THE RESIDUALS
summary(adf)
#Decide based on the plot of the logarithimzed series and the corresponding
#ACF on stationarity of REER for Australia and Mexico
plot(log(REER[-(1:111),"Australia"]), type="l")
plot(log(REER[-(1:111),"Mexico"]), type="l")
acf(log(REER[-(1:111),"Australia"]))
acf(log(REER[-(1:111),"Mexico"]))
for ( i in CUR){
x = log(REER[-(1:111),i])  # remove Bretton Woods periods and logarithmize
# ADF-test with drift
pmax = round(12*(length(x)/100)^0.25, 0)  # truncation lag according to Schwert (1989)
R.adf = ur.df(x, type="drift", selectlags="AIC", lags=pmax)
R.adf_tp = punitroot(q=R.adf@teststat[1], N=length(x), trend="c", statistic="t") # approximate p-values by MacKinnon (1996)
# KPSS-test with drift
R.kpss = kpss.test(x, null="Level", lshort=FALSE)
# store results
R.indv = rbind(R.indv, data.frame(Country=i,
ADF_lag=length(R.adf@testreg$coefficients[,1])-2,
ADF_phi=R.adf@testreg$coefficients[2,1],
ADF_t  =R.adf@teststat[1],
ADF_tp =R.adf_tp,
ADF_int=R.adf@testreg$coefficients[1,1],
ADF_inp=R.adf@testreg$coefficients[1,4],
KPSS_s =unname(R.kpss$statistic),
KPSS_p =R.kpss$p.value))
}
R.indv
austr_arima<-auto.arima(log(REER[-(1:111),"Australia"]), ic="aic", seasonal=FALSE)
austr_arima
y<-log(dataset$YER)
c<-log(dataset$PCR)
plot(cbind(y,c), type="l")
plot(y,ylim=c(12.5,14.5), type="l")
lines(c,col="blue")
adf = ur.df(y, type="trend", selectlags="BIC")
summary(adf)
adf = ur.df(c, type="trend", selectlags="BIC")
summary(adf)
# We regress by standard OLS including constant term
ciregression = lm(c~y)
austr_arima
finland_arima<-auto.arima(log(REER[-(1:111),"Finland"]), ic="aic", seasonal=FALSE)
str(REER[-(1:111))
REER = read.csv("REER_2016.csv", header=TRUE, sep=";", dec=",")
library(urca)
library(tseries)
library(forecast)
REER = read.csv("REER_2016.csv", header=TRUE, sep=";", dec=",")
CUR  = colnames(REER[,-1])
#Decide based on the plot of the logarithimzed series and the corresponding
#ACF on stationarity of REER for Australia and Mexico
plot(log(REER[-(1:111),"Australia"]), type="l")
plot(log(REER[-(1:111),"Mexico"]), type="l")
acf(log(REER[-(1:111),"Australia"]))
acf(log(REER[-(1:111),"Mexico"]))
R.indv = NULL
for ( i in CUR){
x = log(REER[-(1:111),i])  # remove Bretton Woods periods and logarithmize
# ADF-test with drift
pmax = round(12*(length(x)/100)^0.25, 0)  # truncation lag according to Schwert (1989)
R.adf = ur.df(x, type="drift", selectlags="AIC", lags=pmax)
R.adf_tp = punitroot(q=R.adf@teststat[1], N=length(x), trend="c", statistic="t") # approximate p-values by MacKinnon (1996)
# KPSS-test with drift
R.kpss = kpss.test(x, null="Level", lshort=FALSE)
# store results
R.indv = rbind(R.indv, data.frame(Country=i,
ADF_lag=length(R.adf@testreg$coefficients[,1])-2,
ADF_phi=R.adf@testreg$coefficients[2,1],
ADF_t  =R.adf@teststat[1],
ADF_tp =R.adf_tp,
ADF_int=R.adf@testreg$coefficients[1,1],
ADF_inp=R.adf@testreg$coefficients[1,4],
KPSS_s =unname(R.kpss$statistic),
KPSS_p =R.kpss$p.value))
}
View(REER)
type(REER)
class(REER)
# We regress by standard OLS including constant term
ciregression = lm(c~y)
summary(ciregression)
# coefficients (parameters of the cointegrating vector) signicicant
# obtain the residual c-beta0-beta1*y
e = ciregression$residuals # z=c-beta*y
plot(e,type="l")
# As realistic alternative for unit root is that the series is stationary with constant mean,
# we add a drift term to the test regression. (Note that we do that even though the series has zero mean
# by construction. The inclusion only changes the used table for critical values)
adf = ur.df(e, type="drift", selectlags="BIC")  # ADF TEST OF THE RESIDUALS
summary(adf)
plot(cbind(y,c), type="l")
plot(y,ylim=c(12.5,14.5), type="l")
lines(c,col="blue")
plot(e,type="l")
# As realistic alternative for unit root is that the series is stationary with constant mean,
# we add a drift term to the test regression. (Note that we do that even though the series has zero mean
# by construction. The inclusion only changes the used table for critical values)
adf = ur.df(e, type="none", selectlags="BIC")  # ADF TEST OF THE RESIDUALS
summary(adf)
?ur.df()
# Name: Phuong Nguyen
# Date: 25.11.2018
# This file is where data wrangling is done for the fourth week exercise
# 1. 2. Read in the "Human development" and "Gender inequality" datasets
hd <- read.csv(
"http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/human_development.csv", stringsAsFactors = F)
gii <- read.csv(
"http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/gender_inequality.csv", stringsAsFactors = F, na.strings = "..")
# 3. Explore the datasets
# Structure and summaries of variables in "Human development" dataset
str(hd)
summary(hd)
# Structure and summaries of variables in "Gender inequality" dataset
str(gii)
summary(gii)
# 4. Rename variables into shorter and more descriptive names
colnames(hd)[1] <- 'hdi_rank'
colnames(hd)[2] <- 'country'
colnames(hd)[3] <- 'hdi'
colnames(hd)[4] <- 'life_ex'
colnames(hd)[5] <- 'ex_edu_years'
colnames(hd)[6] <- 'mean_edu_years'
colnames(hd)[7] <- 'gni'
colnames(hd)[8] <- 'gni_rank'
colnames(gii)[1] <- 'gii_rank'
colnames(gii)[2] <- 'country'
colnames(gii)[3] <- 'gii'
colnames(gii)[4] <- 'maternal_death_rate'
colnames(gii)[5] <- 'teen_birth_rate'
colnames(gii)[6] <- 'per_rep_parliment'
colnames(gii)[7] <- 'second_edu_f'
colnames(gii)[8] <- 'second_edu_m'
colnames(gii)[9] <- 'labour_f'
colnames(gii)[10] <- 'labour_m'
# 5. Gii dataset mutation
gii$second_edu_f_m_ratio = gii$second_edu_f / gii$second_edu_m
gii$labour_f_m_ratio = gii$labour_f / gii$labour_m
# 6. Joining hd and gii datasets
library(dplyr)
join_by <- c("country")
human <- inner_join(hd, gii, by = join_by)
str(human)
rm(list=ls())
hd <- read.csv("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/human_development.csv", stringsAsFactors = F)
gii <- read.csv("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/gender_inequality.csv", stringsAsFactors = F, na.strings = "..")
##
##Step 3. Explore datasets
##
# exploring with different functions
str(hd)
str(gii)
dim(hd)
dim(gii)
summary(hd)
summary(gii)
colnames(hd)
colnames(gii)
names(hd) <- c("HDI.rank", "country", "HDI.hdi", "HDI.lifeexpect","HDI.expeyearsedu","HDI,meanyearsedu","GDI.gni","HDI.gnirank")
names(gii) <- c("GII.rank", "country", "GII.gii", "GII.matemortratio","GII.adobirthrate","GII.repinparperc","GII.secedupopF","GII.secedupopM","GII.labourrateF","GII.labourrateM")
# mutating the gii-dataset with dplyr-library
library(dplyr)
gii <- mutate(gii, GII.seceduaratioFM = (GII.secedupopF / GII.secedupopM))
gii <- mutate(gii, GII.labourrateratioFM = (GII.labourrateF / GII.labourrateM))
str(gii)
##
##Step 6. Join and save the dataset
##
# joining the datasets with inner-join which keeps only data (countries) it can find from both datasets.
# Then printing exploring the joined dataset
human <- inner_join(hd, gii, by = "country")
str(human)
dim(human)
summary(human)
rm(list=ls())
# Reading the data
hd <- read.csv("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/human_development.csv", stringsAsFactors = F)
# GII = gender inequality
gii <- read.csv("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/gender_inequality.csv", stringsAsFactors = F, na.strings = "..")
# Structure and dimensions
str(hd) # 195 observations, 8 variables
summary(hd)
str(gii) # 195 observations, 8 variables
summary(gii)
# Renaming the variables
names(hd) <- c("HDI.Rank", "Country", "HDI", "Life.Exp", "Edu.Exp", "Edu.Mean", "GNI", "GNI.Minus.Rank")
names(gii) <- c("GII.Rank", "Country", "GII", "Mat.Mor", "Ado.Birth", "Parli.F", "Edu2.F", "Edu2.M", "Labo.F", "Labo.M")
# Creating new variables to the gender equality dataset, ratio of females and males with secondary education, and labor force
gii$Edu2.FM <- round(gii$Edu2.F/gii$Edu2.M, 3)
gii$Labo.FM <- round(gii$Labo.F/gii$Labo.M, 3)
head(gii)
# Merging the two datasets (inner join)
human <- merge(hd, gii, by = "Country")
dim(human) # 195 observations and 19 variables
library(stringr)
library(tidyr)
library(plyr)
library(ggplot2)
library(dplyr)
install.packages(c("haven", "mgcv", "readr", "survival"))
human <- read.table("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/human1.txt", sep  =",", header = T)
# look at the (column) names of human
names(human)
# look at the structure of human
str(human)
# look at the structure of the GNI column in 'human'
str(human$GNI)
# remove the commas from GNI and print out a numeric version of it
str_replace(human$GNI, pattern=",", replace ="")%>% as.numeric
str(human$GNI)
str(human$GNI)
# remove the commas from GNI and print out a numeric version of it
human$GNI<-str_replace(human$GNI, pattern=",", replace ="")%>% as.numeric
str(human$GNI)
# look at the structure of human
str(human)
# read the human data
human <- read.table("human.txt", sep=",")
setwd("~/Documents/GitHub/IODS-project")
# read the human data
human <- read.table("human.txt", sep=",")
# look at the (column) names of human
names(human)
# look at the structure of human
str(human)
# look at the structure of the GNI column in 'human'
str(human$GNI)
# look at the structure of the GNI column in 'human'
str(human$GNI)
# columns to keep
keep <- c("Country", "Edu2.FM", "Labo.FM", "Life.Exp", "Edu.Exp", "GNI", "Mat.Mor", "Ado.Birth", "Parli.F")
# select the 'keep' columns
human <- select(human, one_of(keep))
# print out a completeness indicator of the 'human' data
complete.cases(human)
# print out the data along with a completeness indicator as the last column
data.frame(human[-1], comp = complete.cases(human))
# filter out all rows with NA values
human_ <- filter(human, comp==TRUE)
comp<-complete.cases(human)
# print out the data along with a completeness indicator as the last column
data.frame(human[-1], comp = complete.cases(human))
# filter out all rows with NA values
human_ <- filter(human, comp==TRUE)
library(GGally)
# add countries as rownames
rownames(human_) <- human_$Country
# remove the Country variable
human_ <- select(human, -Country)
str(human_)
keep <- c("Country", "Edu2.FM", "Labo.FM", "Life.Exp", "Edu.Exp", "GNI", "Mat.Mor", "Ado.Birth", "Parli.F")
# select the 'keep' columns
human <- select(human, one_of(keep))
# print out a completeness indicator of the 'human' data
comp<-complete.cases(human)
# print out the data along with a completeness indicator as the last column
data.frame(human[-1], comp = complete.cases(human))
# filter out all rows with NA values
human_ <- filter(human, comp==TRUE)
# add countries as rownames
rownames(human_) <- human_$Country
# remove the Country variable
human_ <- select(human, -Country)
str(human_)
tail(human, 10)
keep <- c("Country", "Edu2.FM", "Labo.FM", "Life.Exp", "Edu.Exp", "GNI", "Mat.Mor", "Ado.Birth", "Parli.F")
# select the 'keep' columns
human <- select(human, one_of(keep))
# print out a completeness indicator of the 'human' data
comp<-complete.cases(human)
# print out the data along with a completeness indicator as the last column
data.frame(human[-1], comp = complete.cases(human))
# look at the last 10 observations of human
tail(human, 10)
# define the last indice we want to keep
last <- nrow(human) - 7
# choose everything until the last 7 observations
human_ <- human[1:last,]
human_
# filter out all rows with NA values
human_ <- filter(human, comp==TRUE)
# add countries as rownames
rownames(human_) <- human_$Country
# remove the Country variable
human_ <- select(human, -Country)
str(human_)
# define the last indice we want to keep
last <- nrow(human) - 7
# choose everything until the last 7 observations
human_ <- human[1:last,]
human_
str(human_)
# filter out all rows with NA values
human_ <- filter(human, comp==TRUE)
str(human_)
# add countries as rownames
rownames(human_) <- human_$Country
# remove the Country variable
human_ <- select(human, -Country)
str(human_)
human <- read.table("human.txt", sep=",")
# read the human data
human <- read.table("human.txt", sep=",")
# read the human data
human <- read.table("human.txt", sep=",")
setwd("~/Documents/GitHub/IODS-project/data")
# read the human data
human <- read.table("human.txt", sep=",")
rm(list=ls())
library(stringr)
library(tidyr)
library(dplyr)
library(ggplot2)
library(GGally)
# read the human data
human <- read.table("human.txt", sep=",")
# read the human data
human <- read.table("human.txt", sep=",")
# read the human data
human <- read.table("human.txt", sep=",")
setwd("~/Documents/GitHub/IODS-project/data")
rm(list=ls())
library(stringr)
library(tidyr)
library(dplyr)
library(ggplot2)
library(GGally)
# read the human data
human <- read.table("human.txt", sep=",")
# look at the (column) names of human
names(human)
# read the human data
human <- read.table("human.txt", sep=",")
setwd("~/Documents/GitHub/IODS-project")
# read the human data
human <- read.table("human.txt", sep=",")
# read the human data
human <- read.table("human.txt", sep=",")
# read the human data
human <- read.table("human.txt", sep=",")
# read the human data
human <- read.table("human.txt", sep=",")
setwd("~/Documents/GitHub/IODS-project/data")
# read the human data
human <- read.table("human.txt", sep=",")
